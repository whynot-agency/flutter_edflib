// ignore_for_file: type=lint

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// edflib: cross-platform library for reading and writing edf files
class EdfLib {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  EdfLib(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  EdfLib.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Opens an existing file for reading.
  ///
  /// @param[in] path
  /// null-terminated string containing the \p path to the file
  ///
  /// @param[out] edfhdr
  /// pointer to an \p edflib_hdr_t struct, all fields in this struct will be overwritten,
  /// it will be filled with all the relevant header- and signalinfo/parameters
  ///
  /// @param[in] read_annotations
  /// Must have one of the following values:
  /// - EDFLIB_DO_NOT_READ_ANNOTATIONS      annotations will not be read (this can save time when opening a very large EDF+ or BDF+ file
  /// - EDFLIB_READ_ANNOTATIONS             annotations will be read immediately, stops when an annotation has
  /// been found which contains the description "Recording ends"
  /// - EDFLIB_READ_ALL_ANNOTATIONS         all annotations will be read immediately
  ///
  /// @return
  /// 0 on success, in case of an error it returns -1 and an error code will be set in the member "filetype" of edfhdr.
  /// This function is required if you want to read a file
  ///
  /// In case of a file format error (-3), try to open the file with EDFbrowser: https://www.teuniz.net/edfbrowser/
  /// It will give you full details about the cause of the error and it can also fix most errors.
  int open_file_readonly(
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<edflib_hdr_t> edfhdr,
    int read_annotations,
  ) {
    return _open_file_readonly(
      path,
      edfhdr,
      read_annotations,
    );
  }

  late final _open_file_readonlyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<edflib_hdr_t>,
              ffi.Int)>>('edfopen_file_readonly');
  late final _open_file_readonly = _open_file_readonlyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<edflib_hdr_t>, int)>();

  /// Reads \p n samples from \p edfsignal, starting from the current sample position indicator, into \p buf (edfsignal starts at 0).
  /// The values are converted to their physical values e.g. microVolts, beats per minute, etc.
  ///
  /// @param[in] handle
  /// File handle.
  /// @param[in] edfsignal
  /// The zero-based index of the signal.
  /// @param[in] n
  /// Number of samples to read. The sample position indicator will be increased with the same amount.
  /// @param[out] buf
  /// Pointer to a buffer, size must be equal to, or bigger than, sizeof(double[n])
  ///
  /// @return
  /// The number of samples read (this can be less than \p n or zero!) or -1 in case of an error
  int read_physical_samples(
    int handle,
    int edfsignal,
    int n,
    ffi.Pointer<ffi.Double> buf,
  ) {
    return _read_physical_samples(
      handle,
      edfsignal,
      n,
      buf,
    );
  }

  late final _read_physical_samplesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Double>)>>('edfread_physical_samples');
  late final _read_physical_samples = _read_physical_samplesPtr
      .asFunction<int Function(int, int, int, ffi.Pointer<ffi.Double>)>();

  /// Reads \p n samples from \p edfsignal, starting from the current sample position indicator, into \p buf (edfsignal starts at 0).
  /// The values are the "raw" digital values (e.g. from an ADC).
  ///
  /// @param[in] handle
  /// File handle.
  /// @param[in] edfsignal
  /// The zero-based index of the signal.
  /// @param[in] n
  /// Number of samples to read. The sample position indicator will be increased with the same amount.
  /// @param[out] buf
  /// Pointer to a buffer, size must be equal to, or bigger than, sizeof(double[n])
  ///
  /// @return
  /// The number of samples read (this can be less than \p n or zero!) or -1 in case of an error
  int read_digital_samples(
    int handle,
    int edfsignal,
    int n,
    ffi.Pointer<ffi.Int> buf,
  ) {
    return _read_digital_samples(
      handle,
      edfsignal,
      n,
      buf,
    );
  }

  late final _read_digital_samplesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Int>)>>('edfread_digital_samples');
  late final _read_digital_samples = _read_digital_samplesPtr
      .asFunction<int Function(int, int, int, ffi.Pointer<ffi.Int>)>();

  /// Sets the sample position indicator for the edfsignal pointed to by \p edfsignal.
  /// The new position, measured in samples, is obtained by adding offset samples to the position specified by \p whence.
  /// If \p whence is set to EDFSEEK_SET, EDFSEEK_CUR, or EDFSEEK_END, the offset is relative to the start of the file,
  /// the current position indicator, or end-of-file, respectively.
  /// Note that every signal has it's own independent sample position indicator and \p edfseek() affects only one of them.
  ///
  /// @param[in] handle
  /// File handle.
  /// @param[in] edfsignal
  /// The zero-based index of the signal.
  /// @param[in] offset
  /// Offset measured in samples.
  /// @param[in] whence
  /// Reference for \p offset:
  /// - EDFSEEK_SET start of the file
  /// - EDFSEEK_CUR current position
  /// - EDFSEEK_END end of the file
  ///
  /// @return
  /// The current offset or -1 in case of an error.
  int seek(
    int handle,
    int edfsignal,
    int offset,
    int whence,
  ) {
    return _seek(
      handle,
      edfsignal,
      offset,
      whence,
    );
  }

  late final _seekPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(
              ffi.Int, ffi.Int, ffi.LongLong, ffi.Int)>>('edfseek');
  late final _seek = _seekPtr.asFunction<int Function(int, int, int, int)>();

  /// Obtains the current value of the sample position indicator for the edfsignal pointed to by \p edfsignal.
  /// Note that every signal has it's own independent sample position indicator and \p edftell() affects only one of them.
  ///
  /// @param[in] handle
  /// File handle.
  /// @param[in] edfsignal
  /// The zero-based index of the signal.
  ///
  /// @return
  /// The current offset or -1 in case of an error.
  int tell(
    int handle,
    int edfsignal,
  ) {
    return _tell(
      handle,
      edfsignal,
    );
  }

  late final _tellPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Int, ffi.Int)>>(
          'edftell');
  late final _tell = _tellPtr.asFunction<int Function(int, int)>();

  /// Sets the sample position indicator for the edfsignal pointed to by \p edfsignal to the beginning of the file.
  /// It is equivalent to: \p edfseek(handle, edfsignal, 0LL, EDFSEEK_SET).
  /// Note that every signal has it's own independent sample position indicator and \p edfrewind() affects only one of them.
  ///
  /// @param[in] handle
  /// File handle.
  /// @param[in] edfsignal
  /// The zero-based index of the signal.
  ///
  /// @return
  /// 0 on success or -1 in case of an error.
  int rewind(
    int handle,
    int edfsignal,
  ) {
    return _rewind(
      handle,
      edfsignal,
    );
  }

  late final _rewindPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'edfrewind');
  late final _rewind = _rewindPtr.asFunction<int Function(int, int)>();

  /// Fills the edflib_annotation_t structure with the annotation \p n.
  /// The string that describes the annotation/event is encoded in UTF-8.
  /// To obtain the number of annotations in a file, check edf_hdr_struct -> annotations_in_file.
  ///
  /// @param[in] handle
  /// File handle.
  /// @param[in] n
  /// The zero-based index number of the list of annotations.
  /// @param[out] annot
  /// Pointer to a struct that will be filled with the annotation.
  ///
  /// @return
  /// 0 on success or -1 in case of an error.
  int get_annotation(
    int handle,
    int n,
    ffi.Pointer<edflib_annotation_t> annot,
  ) {
    return _get_annotation(
      handle,
      n,
      annot,
    );
  }

  late final _get_annotationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Int,
              ffi.Pointer<edflib_annotation_t>)>>('edf_get_annotation');
  late final _get_annotation = _get_annotationPtr
      .asFunction<int Function(int, int, ffi.Pointer<edflib_annotation_t>)>();

  /// Closes (and in case of writing, finalizes) the file.
  ///
  /// This function MUST be called when you have finished reading or writing
  /// This function is required after reading or writing. Failing to do so will cause
  /// unnecessary memory usage and in case of writing it will cause a corrupted or incomplete file.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @return
  /// 0 on success or -1 in case of an error.
  int close_file(
    int handle,
  ) {
    return _close_file(
      handle,
    );
  }

  late final _close_filePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('edfclose_file');
  late final _close_file = _close_filePtr.asFunction<int Function(int)>();

  /// Returns the version number of this library, multiplied by hundred. if version is "1.00" then it will return 100.
  ///
  /// @return
  /// The version number.
  int version() {
    return _version();
  }

  late final _versionPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('edflib_version');
  late final _version = _versionPtr.asFunction<int Function()>();

  /// Returns 1 if the file is in use, either for reading or writing, otherwise returns 0.
  ///
  /// @param[in] path
  /// Pointer to a null-terminated string that contains the path to the file.
  ///
  /// @return
  /// 1 if the file is in use (either for reading or writing), otherwise 0.
  int is_file_used(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _is_file_used(
      path,
    );
  }

  late final _is_file_usedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'edflib_is_file_used');
  late final _is_file_used =
      _is_file_usedPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Returns the number of open files.
  ///
  /// @return
  /// The number of open files, either for reading or writing.
  int get_number_of_open_files() {
    return _get_number_of_open_files();
  }

  late final _get_number_of_open_filesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'edflib_get_number_of_open_files');
  late final _get_number_of_open_files =
      _get_number_of_open_filesPtr.asFunction<int Function()>();

  /// Returns the handle of an open file, either for reading or writing.
  ///
  /// @param[in] file_number
  /// A zero based index number of the list of open files.
  ///
  /// @return
  /// The file handle or -1 if the file_number >= number of open files.
  int get_handle(
    int file_number,
  ) {
    return _get_handle(
      file_number,
    );
  }

  late final _get_handlePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'edflib_get_handle');
  late final _get_handle = _get_handlePtr.asFunction<int Function(int)>();

  /// Opens an new file for writing. Warning: an already existing file with the same name will be silently overwritten without advance warning!<br>
  /// This function is required if you want to write a file (or use edfopen_file_writeonly_with_params())
  ///
  /// @param[in] path
  /// A null-terminated string containing the path and name of the file
  ///
  /// @param[in] filetype
  /// Must be EDFLIB_FILETYPE_EDFPLUS or EDFLIB_FILETYPE_BDFPLUS.
  ///
  /// @param[in] number_of_signals
  /// The number of signals you want to store into the file<br>
  /// (excluding annotation signals, the library will take care of that).
  ///
  /// @return
  /// A file handle on success or a negative number in case of an error:
  /// - EDFLIB_MALLOC_ERROR
  /// - EDFLIB_NO_SUCH_FILE_OR_DIRECTORY
  /// - EDFLIB_MAXFILES_REACHED
  /// - EDFLIB_FILE_ALREADY_OPENED
  /// - EDFLIB_NUMBER_OF_SIGNALS_INVALID
  /// - EDFLIB_ARCH_ERROR
  int open_file_writeonly(
    ffi.Pointer<ffi.Char> path,
    int filetype,
    int number_of_signals,
  ) {
    return _open_file_writeonly(
      path,
      filetype,
      number_of_signals,
    );
  }

  late final _open_file_writeonlyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Int)>>('edfopen_file_writeonly');
  late final _open_file_writeonly = _open_file_writeonlyPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  /// This is a convenience function that can create a new EDF file and initializes the most important parameters.<br>
  /// It assumes that all signals are sharing the same parameters (you can still change them though).<br>
  /// Warning: an already existing file with the same name will be silently overwritten without advance warning!<br>
  ///
  /// @param[in] path
  /// A null-terminated string containing the path and name of the file.
  ///
  /// @param[in] filetype
  /// Must be EDFLIB_FILETYPE_EDFPLUS or EDFLIB_FILETYPE_BDFPLUS.
  ///
  /// @param[in] number_of_signals
  /// The number of signals you want to store into the file<br>
  /// (excluding annotation signals, the library will take care of that).
  ///
  /// @param[in] samplefrequency
  /// Sample frequency for all signals. (In reality, it sets the number of samples per datarecord which equals the sample frequency only when<br>
  /// the datarecords have a duration of one second which is the default here.)
  ///
  /// @param[in] phys_max_min
  /// Physical maximum and minimum for all signals.
  ///
  /// @param[in] phys_dim
  /// Pointer to a NULL-terminated ASCII-string containing the physical dimension (unit) for all signals ("uV", "BPM", "mA", "Degr.", etc.).
  ///
  /// @return
  /// A file handle on success or a negative number in case of an error:
  /// - EDFLIB_MALLOC_ERROR
  /// - EDFLIB_NO_SUCH_FILE_OR_DIRECTORY
  /// - EDFLIB_MAXFILES_REACHED
  /// - EDFLIB_FILE_ALREADY_OPENED
  /// - EDFLIB_NUMBER_OF_SIGNALS_INVALID
  /// - EDFLIB_ARCH_ERROR
  int open_file_writeonly_with_params(
    ffi.Pointer<ffi.Char> path,
    int filetype,
    int number_of_signals,
    int samplefrequency,
    double phys_max_min,
    ffi.Pointer<ffi.Char> phys_dim,
  ) {
    return _open_file_writeonly_with_params(
      path,
      filetype,
      number_of_signals,
      samplefrequency,
      phys_max_min,
      phys_dim,
    );
  }

  late final _open_file_writeonly_with_paramsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Double,
              ffi.Pointer<ffi.Char>)>>('edfopen_file_writeonly_with_params');
  late final _open_file_writeonly_with_params =
      _open_file_writeonly_with_paramsPtr.asFunction<
          int Function(ffi.Pointer<ffi.Char>, int, int, int, double,
              ffi.Pointer<ffi.Char>)>();

  /// Sets the sample frequency of signal edfsignal. In reality, it sets the number of samples in a datarecord<br>
  /// which equals the sample frequency only when the datarecords have a duration of one second.<br>
  /// The effective sample frequency is: samplefrequency / datarecord duration<br>
  /// This function is required for every signal (except when using edfopen_file_writeonly_with_params()) and can be called<br>
  /// only after opening a file in write mode and before the first sample write action.<br>
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] edfsignal
  /// The zero-based index of the signal.
  ///
  /// @param[in] samplefrequency
  /// Sample frequency, must be > 0;
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_samplefrequency(
    int handle,
    int edfsignal,
    int samplefrequency,
  ) {
    return _set_samplefrequency(
      handle,
      edfsignal,
      samplefrequency,
    );
  }

  late final _set_samplefrequencyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'edf_set_samplefrequency');
  late final _set_samplefrequency =
      _set_samplefrequencyPtr.asFunction<int Function(int, int, int)>();

  /// Sets the maximum physical value of signal edfsignal. (the value of the input of the ADC when the output equals the value of "digital maximum")<br>
  /// It is the highest value that the equipment is able to record. It does not necessarily mean the signal recorded reaches this level.<br>
  /// In other words, it is the highest value that CAN occur in the recording.<br>
  /// Must be un-equal to physical minimum.<br>
  /// This function is required for every signal (except when using edfopen_file_writeonly_with_params()) and can be called<br>
  /// only after opening a file in write mode and before the first sample write action.<br>
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] edfsignal
  /// The zero-based index of the signal.
  ///
  /// @param[in] phys_max
  /// Physical maximum, must be != physical minimum;
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_physical_maximum(
    int handle,
    int edfsignal,
    double phys_max,
  ) {
    return _set_physical_maximum(
      handle,
      edfsignal,
      phys_max,
    );
  }

  late final _set_physical_maximumPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Double)>>(
      'edf_set_physical_maximum');
  late final _set_physical_maximum =
      _set_physical_maximumPtr.asFunction<int Function(int, int, double)>();

  /// Sets the minimum physical value of signal edfsignal. (the value of the input of the ADC when the output equals the value of "digital minimum")<br>
  /// It is the lowest value that the equipment is able to record. It does not necessarily mean the signal recorded reaches this level.<br>
  /// In other words, it is the lowest value that CAN occur in the recording.<br>
  /// Must be un-equal to physical maximum.<br>
  /// This function is required for every signal (except when using edfopen_file_writeonly_with_params()) and can be called<br>
  /// only after opening a file in write mode and before the first sample write action.<br>
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] edfsignal
  /// The zero-based index of the signal.
  ///
  /// @param[in] phys_min
  /// Physical minimum, must be != physical maximum;
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_physical_minimum(
    int handle,
    int edfsignal,
    double phys_min,
  ) {
    return _set_physical_minimum(
      handle,
      edfsignal,
      phys_min,
    );
  }

  late final _set_physical_minimumPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Double)>>(
      'edf_set_physical_minimum');
  late final _set_physical_minimum =
      _set_physical_minimumPtr.asFunction<int Function(int, int, double)>();

  /// Sets the maximum digital value of signal edfsignal. The maximum value is 32767 for EDF+ and 8388607 for BDF+.<br>
  /// It is the highest value that the equipment is able to record. It does not necessarily mean the signal recorded reaches this level.<br>
  /// In other words, it is the highest value that CAN occur in the recording.<br>
  /// Must be higher than digital minimum.<br>
  /// This function is required for every signal (except when using edfopen_file_writeonly_with_params()) and can be called<br>
  /// only after opening a file in write mode and before the first sample write action.<br>
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] edfsignal
  /// The zero-based index of the signal.
  ///
  /// @param[in] dig_max
  /// Digital maximum, must be > digital minimum;
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_digital_maximum(
    int handle,
    int edfsignal,
    int dig_max,
  ) {
    return _set_digital_maximum(
      handle,
      edfsignal,
      dig_max,
    );
  }

  late final _set_digital_maximumPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'edf_set_digital_maximum');
  late final _set_digital_maximum =
      _set_digital_maximumPtr.asFunction<int Function(int, int, int)>();

  /// Sets the minimum digital value of signal edfsignal. The minimum value is -32768 for EDF+ and -8388608 for BDF+.<br>
  /// It is the lowest value that the equipment is able to record. It does not necessarily mean the signal recorded reaches this level.<br>
  /// In other words, it is the lowest value that CAN occur in the recording.<br>
  /// Must be lower than digital maximum.<br>
  /// This function is required for every signal (except when using edfopen_file_writeonly_with_params()) and can be called<br>
  /// only after opening a file in write mode and before the first sample write action.<br>
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] edfsignal
  /// The zero-based index of the signal.
  ///
  /// @param[in] dig_min
  /// Digital minimum, must be < digital maximum;
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_digital_minimum(
    int handle,
    int edfsignal,
    int dig_min,
  ) {
    return _set_digital_minimum(
      handle,
      edfsignal,
      dig_min,
    );
  }

  late final _set_digital_minimumPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'edf_set_digital_minimum');
  late final _set_digital_minimum =
      _set_digital_minimumPtr.asFunction<int Function(int, int, int)>();

  /// Sets the label (name) of signal \p edfsignal. ("EEG FP1", "SaO2", etc.).<br>
  /// This function is recommended for every signal when you want to write a file<br>
  /// and can be called only after opening a file in write mode and before the first sample write action.<br>
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] edfsignal
  /// The zero-based index of the signal.
  ///
  /// @param[in] label
  /// A pointer to a NULL-terminated ASCII-string containing the label (name) of the signal \p edfsignal.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_label(
    int handle,
    int edfsignal,
    ffi.Pointer<ffi.Char> label,
  ) {
    return _set_label(
      handle,
      edfsignal,
      label,
    );
  }

  late final _set_labelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Int, ffi.Pointer<ffi.Char>)>>('edf_set_label');
  late final _set_label =
      _set_labelPtr.asFunction<int Function(int, int, ffi.Pointer<ffi.Char>)>();

  /// Sets the prefilter of signal \p edfsignal e.g. "HP:0.1Hz", "LP:75Hz N:50Hz", etc.<br>
  /// This function is optional and can be called only after opening a file in writemode and<br>
  /// before the first sample write action.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] edfsignal
  /// The zero-based index of the signal.
  ///
  /// @param[in] prefilter
  /// A pointer to a NULL-terminated ASCII-string containing the prefilter text of the signal \p edfsignal.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_prefilter(
    int handle,
    int edfsignal,
    ffi.Pointer<ffi.Char> prefilter,
  ) {
    return _set_prefilter(
      handle,
      edfsignal,
      prefilter,
    );
  }

  late final _set_prefilterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Int, ffi.Pointer<ffi.Char>)>>('edf_set_prefilter');
  late final _set_prefilter = _set_prefilterPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Char>)>();

  /// Sets the transducer of signal \p edfsignal e.g. "AgAgCl cup electrodes", etc.<br>
  /// This function is optional and can be called only after opening a file in writemode and<br>
  /// before the first sample write action.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] edfsignal
  /// The zero-based index of the signal.
  ///
  /// @param[in] transducer
  /// A pointer to a NULL-terminated ASCII-string containing the transducer text of the signal \p edfsignal.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_transducer(
    int handle,
    int edfsignal,
    ffi.Pointer<ffi.Char> transducer,
  ) {
    return _set_transducer(
      handle,
      edfsignal,
      transducer,
    );
  }

  late final _set_transducerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Int, ffi.Pointer<ffi.Char>)>>('edf_set_transducer');
  late final _set_transducer = _set_transducerPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Char>)>();

  /// Sets the physical dimension (unit) of signal \p edfsignal. ("uV", "BPM", "mA", "Degr.", etc.).<br>
  /// This function is recommended for every signal when you want to write a file<br>
  /// and can be called only after opening a file in write mode and before the first sample write action.<br>
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] edfsignal
  /// The zero-based index of the signal.
  ///
  /// @param[in] phys_dim
  /// A pointer to a NULL-terminated ASCII-string containing the physical dimension (unit) of the signal \p edfsignal.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_physical_dimension(
    int handle,
    int edfsignal,
    ffi.Pointer<ffi.Char> phys_dim,
  ) {
    return _set_physical_dimension(
      handle,
      edfsignal,
      phys_dim,
    );
  }

  late final _set_physical_dimensionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('edf_set_physical_dimension');
  late final _set_physical_dimension = _set_physical_dimensionPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Char>)>();

  /// Sets the startdate and starttime.<br>
  /// If not called, the library will use the system date and time at runtime.<br>
  /// This function is optional and can be called only after opening a file in write mode<br>
  /// and before the first sample write action.<br>
  /// Note: for anonymization purposes, the consensus is to use 1985-01-01 00:00:00 for the startdate and starttime.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] startdate_year
  /// 1985 - 2084 inclusive
  ///
  /// @param[in] startdate_month
  /// 1 - 12 inclusive
  ///
  /// @param[in] startdate_day
  /// 1 - 31 inclusive
  ///
  /// @param[in] starttime_hour
  /// 0 - 23 inclusive
  ///
  /// @param[in] starttime_minute
  /// 0 - 59 inclusive
  ///
  /// @param[in] starttime_second
  /// 0 - 59 inclusive
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_startdatetime(
    int handle,
    int startdate_year,
    int startdate_month,
    int startdate_day,
    int starttime_hour,
    int starttime_minute,
    int starttime_second,
  ) {
    return _set_startdatetime(
      handle,
      startdate_year,
      startdate_month,
      startdate_day,
      starttime_hour,
      starttime_minute,
      starttime_second,
    );
  }

  late final _set_startdatetimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int, ffi.Int, ffi.Int,
              ffi.Int)>>('edf_set_startdatetime');
  late final _set_startdatetime = _set_startdatetimePtr
      .asFunction<int Function(int, int, int, int, int, int, int)>();

  /// Sets the subject name<br>
  /// This function is optional and can be called only after opening a file in writemode and<br>
  /// before the first sample write action.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] patientname
  /// A pointer to a NULL-terminated ASCII-string containing the subject name.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_patientname(
    int handle,
    ffi.Pointer<ffi.Char> patientname,
  ) {
    return _set_patientname(
      handle,
      patientname,
    );
  }

  late final _set_patientnamePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'edf_set_patientname');
  late final _set_patientname = _set_patientnamePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Sets the subject code<br>
  /// This function is optional and can be called only after opening a file in writemode and<br>
  /// before the first sample write action.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] patientcode
  /// A pointer to a NULL-terminated ASCII-string containing the subject code.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_patientcode(
    int handle,
    ffi.Pointer<ffi.Char> patientcode,
  ) {
    return _set_patientcode(
      handle,
      patientcode,
    );
  }

  late final _set_patientcodePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'edf_set_patientcode');
  late final _set_patientcode = _set_patientcodePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Sets the sex of the subject. 1 is male, 0 is female.<br>
  /// This function is optional and can be called only after opening a file in writemode<br>
  /// and before the first sample write action.<br>
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] sex
  /// 1: male, 0: female.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_sex(
    int handle,
    int sex,
  ) {
    return _set_sex(
      handle,
      sex,
    );
  }

  late final _set_sexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'edf_set_sex');
  late final _set_sex = _set_sexPtr.asFunction<int Function(int, int)>();

  int set_gender(
    int handle,
    int sex,
  ) {
    return _set_gender(
      handle,
      sex,
    );
  }

  late final _set_genderPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'edf_set_gender');
  late final _set_gender = _set_genderPtr.asFunction<int Function(int, int)>();

  /// Sets the subject birthdate.<br>
  /// This function is optional and can be called only after opening a file in write mode<br>
  /// and before the first sample write action.<br>
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] birthdate_year
  /// 1800 - 3000 inclusive
  ///
  /// @param[in] birthdate_month
  /// 1 - 12 inclusive
  ///
  /// @param[in] birthdate_day
  /// 1 - 31 inclusive
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_birthdate(
    int handle,
    int birthdate_year,
    int birthdate_month,
    int birthdate_day,
  ) {
    return _set_birthdate(
      handle,
      birthdate_year,
      birthdate_month,
      birthdate_day,
    );
  }

  late final _set_birthdatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Int, ffi.Int, ffi.Int)>>('edf_set_birthdate');
  late final _set_birthdate =
      _set_birthdatePtr.asFunction<int Function(int, int, int, int)>();

  /// Sets the additional subject info<br>
  /// This function is optional and can be called only after opening a file in writemode and<br>
  /// before the first sample write action.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] patient_additional
  /// A pointer to a NULL-terminated ASCII-string containing the additional subject info.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_patient_additional(
    int handle,
    ffi.Pointer<ffi.Char> patient_additional,
  ) {
    return _set_patient_additional(
      handle,
      patient_additional,
    );
  }

  late final _set_patient_additionalPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'edf_set_patient_additional');
  late final _set_patient_additional = _set_patient_additionalPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Sets the administration code<br>
  /// This function is optional and can be called only after opening a file in writemode and<br>
  /// before the first sample write action.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] admincode
  /// A pointer to a NULL-terminated ASCII-string containing the administration code.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_admincode(
    int handle,
    ffi.Pointer<ffi.Char> admincode,
  ) {
    return _set_admincode(
      handle,
      admincode,
    );
  }

  late final _set_admincodePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'edf_set_admincode');
  late final _set_admincode =
      _set_admincodePtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Sets the technicians name or code<br>
  /// This function is optional and can be called only after opening a file in writemode and<br>
  /// before the first sample write action.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] technician
  /// A pointer to a NULL-terminated ASCII-string containing the technicians name or code.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_technician(
    int handle,
    ffi.Pointer<ffi.Char> technician,
  ) {
    return _set_technician(
      handle,
      technician,
    );
  }

  late final _set_technicianPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'edf_set_technician');
  late final _set_technician =
      _set_technicianPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Sets the equipment brand and/or model<br>
  /// This function is optional and can be called only after opening a file in writemode and<br>
  /// before the first sample write action.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] equipment
  /// A pointer to a NULL-terminated ASCII-string containing the equipment brand and/or model<br>
  /// used for the recording.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_equipment(
    int handle,
    ffi.Pointer<ffi.Char> equipment,
  ) {
    return _set_equipment(
      handle,
      equipment,
    );
  }

  late final _set_equipmentPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'edf_set_equipment');
  late final _set_equipment =
      _set_equipmentPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Sets the additional info about the recording.<br>
  /// This function is optional and can be called only after opening a file in writemode and<br>
  /// before the first sample write action.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] recording_additional
  /// A pointer to a NULL-terminated ASCII-string containing the additional info about the recording.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_recording_additional(
    int handle,
    ffi.Pointer<ffi.Char> recording_additional,
  ) {
    return _set_recording_additional(
      handle,
      recording_additional,
    );
  }

  late final _set_recording_additionalPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'edf_set_recording_additional');
  late final _set_recording_additional = _set_recording_additionalPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Writes n physical samples (uV, mA, Ohm) from \p buf belonging to one signal<br>
  /// where n is the samplefrequency of that signal.<br>
  /// Actually, n equals the number of samples per datarecord which equals the samplefrequency only<br>
  /// when the datarecord duration has the default value of one second!<br>
  /// The physical samples will be converted to digital samples using the<br>
  /// values of physical maximum, physical minimum, digital maximum and digital minimum.<br>
  /// Size of \p buf must be equal to or bigger than sizeof(double[samples per datarecord]).<br>
  /// Call this function for every signal in the file. The order is important:<br>
  /// When there are 4 signals in the file,  the order of calling this function<br>
  /// must be: signal 0, signal 1, signal 2, signal 3, signal 0, signal 1, signal 2, etc.<br>
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] buf
  /// A pointer to a buffer containing the samples.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int write_physical_samples(
    int handle,
    ffi.Pointer<ffi.Double> buf,
  ) {
    return _write_physical_samples(
      handle,
      buf,
    );
  }

  late final _write_physical_samplesPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Double>)>>(
      'edfwrite_physical_samples');
  late final _write_physical_samples = _write_physical_samplesPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Double>)>();

  /// Writes physical samples (uV, mA, Ohm) from \p buf <br>
  /// \p buf must be filled with samples from all signals, starting with n samples of signal 0, n samples of signal 1, n samples of signal 2, etc.<br>
  /// where n is the samplefrequency of that signal.<br>
  /// Actually, n equals the number of samples per datarecord which equals the samplefrequency only<br>
  /// when the datarecord duration has the default value of one second!<br>
  /// The physical samples will be converted to digital samples using the<br>
  /// values of physical maximum, physical minimum, digital maximum and digital minimum.<br>
  /// The number of samples written equals the sum of the samples per datarecord of all signals.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] buf
  /// A pointer to a buffer containing the samples.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int blockwrite_physical_samples(
    int handle,
    ffi.Pointer<ffi.Double> buf,
  ) {
    return _blockwrite_physical_samples(
      handle,
      buf,
    );
  }

  late final _blockwrite_physical_samplesPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Double>)>>(
      'edf_blockwrite_physical_samples');
  late final _blockwrite_physical_samples = _blockwrite_physical_samplesPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Double>)>();

  /// Writes n "raw" digital samples from \p buf belonging to one signal<br>
  /// where n is the samplefrequency of that signal.<br>
  /// Actually, n equals the number of samples per datarecord which equals the samplefrequency only<br>
  /// when the datarecord duration has the default value of one second!<br>
  /// Size of \p buf should be equal to or bigger than sizeof(short[samples per datarecord]).<br>
  /// Call this function for every signal in the file. The order is important:<br>
  /// When there are 4 signals in the file,  the order of calling this function<br>
  /// must be: signal 0, signal 1, signal 2, signal 3, signal 0, signal 1, signal 2, etc.<br>
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] buf
  /// A pointer to a buffer containing the samples.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int write_digital_short_samples(
    int handle,
    ffi.Pointer<ffi.Short> buf,
  ) {
    return _write_digital_short_samples(
      handle,
      buf,
    );
  }

  late final _write_digital_short_samplesPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Short>)>>(
      'edfwrite_digital_short_samples');
  late final _write_digital_short_samples = _write_digital_short_samplesPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Short>)>();

  /// Writes n "raw" digital samples from \p buf belonging to one signal<br>
  /// where n is the samplefrequency of that signal.<br>
  /// Actually, n equals the number of samples per datarecord which equals the samplefrequency only<br>
  /// when the datarecord duration has the default value of one second!<br>
  /// The 16 (or 24 in case of BDF+) least significant bits of the samples will be written to the<br>
  /// file without any conversion.<br>
  /// Size of \p buf should be equal to or bigger than sizeof(int[samples per datarecord]).<br>
  /// Call this function for every signal in the file. The order is important:<br>
  /// When there are 4 signals in the file,  the order of calling this function<br>
  /// must be: signal 0, signal 1, signal 2, signal 3, signal 0, signal 1, signal 2, etc.<br>
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] buf
  /// A pointer to a buffer containing the samples.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int write_digital_samples(
    int handle,
    ffi.Pointer<ffi.Int> buf,
  ) {
    return _write_digital_samples(
      handle,
      buf,
    );
  }

  late final _write_digital_samplesPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Int>)>>(
      'edfwrite_digital_samples');
  late final _write_digital_samples = _write_digital_samplesPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Int>)>();

  /// Writes "raw" digital samples from \p buf <br>
  /// \p buf must be filled with samples from all signals, starting with n samples of signal 0, n samples of signal 1, n samples of signal 2, etc.<br>
  /// where n is the samplefrequency of that signal.<br>
  /// Actually, n equals the number of samples per datarecord which equals the samplefrequency only<br>
  /// when the datarecord duration has the default value of one second!<br>
  /// One sample equals 3 bytes, order is little endian (least significant byte first).<br>
  /// Encoding is second's complement, most significant bit of most significant byte is the sign-bit.<br>
  /// Because the size of a 3-byte sample is 24-bit, this function can only be used when writing a BDF+ file.<br>
  /// The number of samples written equals the sum of the samples per datarecord of all signals.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] buf
  /// A pointer to a buffer containing the samples.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int blockwrite_digital_3byte_samples(
    int handle,
    ffi.Pointer<ffi.Void> buf,
  ) {
    return _blockwrite_digital_3byte_samples(
      handle,
      buf,
    );
  }

  late final _blockwrite_digital_3byte_samplesPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Void>)>>(
      'edf_blockwrite_digital_3byte_samples');
  late final _blockwrite_digital_3byte_samples =
      _blockwrite_digital_3byte_samplesPtr
          .asFunction<int Function(int, ffi.Pointer<ffi.Void>)>();

  /// Writes "raw" digital samples from \p buf <br>
  /// \p buf must be filled with samples from all signals, starting with n samples of signal 0, n samples of signal 1, n samples of signal 2, etc.<br>
  /// where n is the samplefrequency of that signal.<br>
  /// Actually, n equals the number of samples per datarecord which equals the samplefrequency only<br>
  /// when the datarecord duration has the default value of one second!<br>
  /// One sample equals 2 bytes, order is little endian (least significant byte first).<br>
  /// Encoding is second's complement, most significant bit of most significant byte is the sign-bit.<br>
  /// Because the size of a 2-byte sample is 16-bit, this function can only be used when writing an EDF+ file.<br>
  /// The number of samples written equals the sum of the samples per datarecord of all signals.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] buf
  /// A pointer to a buffer containing the samples.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int blockwrite_digital_short_samples(
    int handle,
    ffi.Pointer<ffi.Short> buf,
  ) {
    return _blockwrite_digital_short_samples(
      handle,
      buf,
    );
  }

  late final _blockwrite_digital_short_samplesPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Short>)>>(
      'edf_blockwrite_digital_short_samples');
  late final _blockwrite_digital_short_samples =
      _blockwrite_digital_short_samplesPtr
          .asFunction<int Function(int, ffi.Pointer<ffi.Short>)>();

  /// Writes "raw" digital samples from \p buf <br>
  /// \p buf must be filled with samples from all signals, starting with n samples of signal 0, n samples of signal 1, n samples of signal 2, etc.<br>
  /// where n is the samplefrequency of that signal.<br>
  /// Actually, n equals the number of samples per datarecord which equals the samplefrequency only<br>
  /// when the datarecord duration has the default value of one second!<br>
  /// The 16 (or 24 in case of BDF+) least significant bits of the samples will be written to the<br>
  /// file without any conversion.<br>
  /// The number of samples written equals the sum of the samples per datarecord of all signals.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] buf
  /// A pointer to a buffer containing the samples.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int blockwrite_digital_samples(
    int handle,
    ffi.Pointer<ffi.Int> buf,
  ) {
    return _blockwrite_digital_samples(
      handle,
      buf,
    );
  }

  late final _blockwrite_digital_samplesPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Int>)>>(
      'edf_blockwrite_digital_samples');
  late final _blockwrite_digital_samples = _blockwrite_digital_samplesPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Int>)>();

  /// Writes an annotation/event to the file.<br>
  /// This function is optional and can be called only after opening a file in writemode<br>
  /// and before closing the file.<br>
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] onset
  /// microseconds since start of recording.
  ///
  /// @param[in] duration
  /// microseconds, > 0 or -1 if not used.
  ///
  /// @param[in] description
  /// A null-terminated UTF8-string containing the text that describes the event.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int write_annotation_utf8_hr(
    int handle,
    int onset,
    int duration,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _write_annotation_utf8_hr(
      handle,
      onset,
      duration,
      description,
    );
  }

  late final _write_annotation_utf8_hrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.LongLong, ffi.LongLong,
              ffi.Pointer<ffi.Char>)>>('edfwrite_annotation_utf8_hr');
  late final _write_annotation_utf8_hr = _write_annotation_utf8_hrPtr
      .asFunction<int Function(int, int, int, ffi.Pointer<ffi.Char>)>();

  int write_annotation_utf8(
    int handle,
    int onset,
    int duration,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _write_annotation_utf8(
      handle,
      onset,
      duration,
      description,
    );
  }

  late final _write_annotation_utf8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.LongLong, ffi.LongLong,
              ffi.Pointer<ffi.Char>)>>('edfwrite_annotation_utf8');
  late final _write_annotation_utf8 = _write_annotation_utf8Ptr
      .asFunction<int Function(int, int, int, ffi.Pointer<ffi.Char>)>();

  /// Writes an annotation/event to the file.<br>
  /// This function is optional and can be called only after opening a file in writemode<br>
  /// and before closing the file.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] onset
  /// microseconds since start of recording.
  ///
  /// @param[in] duration
  /// microseconds, > 0 or -1 if not used.
  ///
  /// @param[in] description
  /// A null-terminated Latin1-string containing the text that describes the event.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int write_annotation_latin1_hr(
    int handle,
    int onset,
    int duration,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _write_annotation_latin1_hr(
      handle,
      onset,
      duration,
      description,
    );
  }

  late final _write_annotation_latin1_hrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.LongLong, ffi.LongLong,
              ffi.Pointer<ffi.Char>)>>('edfwrite_annotation_latin1_hr');
  late final _write_annotation_latin1_hr = _write_annotation_latin1_hrPtr
      .asFunction<int Function(int, int, int, ffi.Pointer<ffi.Char>)>();

  int write_annotation_latin1(
    int handle,
    int onset,
    int duration,
    ffi.Pointer<ffi.Char> description,
  ) {
    return _write_annotation_latin1(
      handle,
      onset,
      duration,
      description,
    );
  }

  late final _write_annotation_latin1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.LongLong, ffi.LongLong,
              ffi.Pointer<ffi.Char>)>>('edfwrite_annotation_latin1');
  late final _write_annotation_latin1 = _write_annotation_latin1Ptr
      .asFunction<int Function(int, int, int, ffi.Pointer<ffi.Char>)>();

  /// Sets the datarecord duration. The default value is 1 second.<br>
  /// ATTENTION: the argument \p duration is expressed in units of 10 microseconds.<br>
  /// So, if you want to set the datarecord duration to 0.1 second, you must write a value of 10000.<br>
  /// The datarecord duration must be in the range 0.001 to 60 seconds.<br>
  /// This function can be used when you want to use a samplerate<br>
  /// which is not an integer. For example, if you want to use a samplerate of 0.5 Hz,<br>
  /// set the samplefrequency to 5 Hz and the datarecord duration to 10 seconds,<br>
  /// or set the samplefrequency to 1 Hz and the datarecord duration to 2 seconds.<br>
  /// This function is optional and can be called after opening a<br>
  /// file in writemode and before the first sample write action.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] duration
  /// Datarecord duration expressed in units of 10 microSecond.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_datarecord_duration(
    int handle,
    int duration,
  ) {
    return _set_datarecord_duration(
      handle,
      duration,
    );
  }

  late final _set_datarecord_durationPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'edf_set_datarecord_duration');
  late final _set_datarecord_duration =
      _set_datarecord_durationPtr.asFunction<int Function(int, int)>();

  /// Sets the datarecord duration to a very small value.<br>
  /// ATTENTION: the argument \p duration is expressed in units of 1 microSecond.<br>
  /// The datarecord duration must be in the range 1 to 9999 microseconds.<br>
  /// This function can be used when you want to use a very high samplerate.<br>
  /// For example, if you want to use a samplerate of 5 GHz,<br>
  /// set the samplefrequency to 5000 Hz and the datarecord duration to 1 micro-second.<br>
  /// Do not use this function if not necessary.<br>
  /// This function was added to accommodate for high speed ADC's e.g. Digital Sampling Oscilloscopes<br>
  /// This function is optional and can be called after opening a<br>
  /// file in writemode and before the first sample write action.
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] duration
  /// Datarecord duration expressed in units of 1 microSecond.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_micro_datarecord_duration(
    int handle,
    int duration,
  ) {
    return _set_micro_datarecord_duration(
      handle,
      duration,
    );
  }

  late final _set_micro_datarecord_durationPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'edf_set_micro_datarecord_duration');
  late final _set_micro_datarecord_duration =
      _set_micro_datarecord_durationPtr.asFunction<int Function(int, int)>();

  /// Sets the number of annotation signals. The default value is 1.<br>
  /// This function is optional and can be called only after opening a file in writemode<br>
  /// and before the first sample write action.<br>
  /// Normally you don't need to change the default value. Only when the number of annotations<br>
  /// you expect to write is more than the number of datarecords in the recording, you can use<br>
  /// this function to increase the storage space for annotations.<br>
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] annot_signals
  /// Number of annotation signals, must be in the range 1 - 64 inclusive.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_number_of_annotation_signals(
    int handle,
    int annot_signals,
  ) {
    return _set_number_of_annotation_signals(
      handle,
      annot_signals,
    );
  }

  late final _set_number_of_annotation_signalsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'edf_set_number_of_annotation_signals');
  late final _set_number_of_annotation_signals =
      _set_number_of_annotation_signalsPtr.asFunction<int Function(int, int)>();

  /// Sets the subsecond starttime expressed in units of 100 nanoseconds.<br>
  /// Valid range is 0 to 9999999 inclusive. Default is 0.<br>
  /// This function is optional and can be called only after opening a file in writemode<br>
  /// and before the first sample write action.<br>
  /// It is recommended to use a maximum resolution of not more than 100 microseconds.<br>
  /// E.g. use 1234000  to set a starttime offset of 0.1234 seconds (instead of for example 1234217).<br>
  /// In other words, leave the last 3 digits at zero.<br>
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] subsecond
  /// Subsecond starttime expressed in units of 100 nanoseconds.
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_subsecond_starttime(
    int handle,
    int subsecond,
  ) {
    return _set_subsecond_starttime(
      handle,
      subsecond,
    );
  }

  late final _set_subsecond_starttimePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'edf_set_subsecond_starttime');
  late final _set_subsecond_starttime =
      _set_subsecond_starttimePtr.asFunction<int Function(int, int)>();

  /// Sets the preferred position of the annotation channel(s) before, after or in the middle of the list<br>
  /// of regular signals. The default is to put them at the end (after the regular signals).<br>
  /// This function is optional and can be called only after opening a file in writemode<br>
  /// and before the first sample write action.<br>
  ///
  /// @param[in] handle
  /// File handle.
  ///
  /// @param[in] pos
  /// Preferred position of the annotation channel(s):<br>
  /// EDF_ANNOT_IDX_POS_START<br>
  /// EDF_ANNOT_IDX_POS_MIDDLE<br>
  /// EDF_ANNOT_IDX_POS_END<br>
  ///
  /// @return
  /// 0 on success, otherwise -1.<br>
  int set_annot_chan_idx_pos(
    int handle,
    int pos,
  ) {
    return _set_annot_chan_idx_pos(
      handle,
      pos,
    );
  }

  late final _set_annot_chan_idx_posPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'edf_set_annot_chan_idx_pos');
  late final _set_annot_chan_idx_pos =
      _set_annot_chan_idx_posPtr.asFunction<int Function(int, int)>();
}

final class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  @ffi.LongLong()
  external int _mbstateL;
}

enum idtype_t {
  P_ALL(0),
  P_PID(1),
  P_PGID(2);

  final int value;
  const idtype_t(this.value);

  static idtype_t fromValue(int value) => switch (value) {
        0 => P_ALL,
        1 => P_PID,
        2 => P_PGID,
        _ => throw ArgumentError("Unknown value for idtype_t: $value"),
      };
}

final class sigval extends ffi.Union {
  @ffi.Int()
  external int sival_int;

  external ffi.Pointer<ffi.Void> sival_ptr;
}

final class __sigaction_u extends ffi.Union {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      __sa_handler;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Int, ffi.Pointer<__siginfo>, ffi.Pointer<ffi.Void>)>>
      __sa_sigaction;
}

final class __siginfo extends ffi.Struct {
  @ffi.Int()
  external int si_signo;

  @ffi.Int()
  external int si_errno;

  @ffi.Int()
  external int si_code;

  @pid_t()
  external int si_pid;

  @uid_t()
  external int si_uid;

  @ffi.Int()
  external int si_status;

  external ffi.Pointer<ffi.Void> si_addr;

  external sigval si_value;

  @ffi.Long()
  external int si_band;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedLong> __pad;
}

typedef pid_t = __darwin_pid_t;
typedef __darwin_pid_t = __int32_t;
typedef __int32_t = ffi.Int;
typedef Dart__int32_t = int;
typedef uid_t = __darwin_uid_t;
typedef __darwin_uid_t = __uint32_t;
typedef __uint32_t = ffi.UnsignedInt;
typedef Dart__uint32_t = int;

final class wait extends ffi.Opaque {}

enum clockid_t {
  _CLOCK_REALTIME(0),
  _CLOCK_MONOTONIC(6),
  _CLOCK_MONOTONIC_RAW(4),
  _CLOCK_MONOTONIC_RAW_APPROX(5),
  _CLOCK_UPTIME_RAW(8),
  _CLOCK_UPTIME_RAW_APPROX(9),
  _CLOCK_PROCESS_CPUTIME_ID(12),
  _CLOCK_THREAD_CPUTIME_ID(16);

  final int value;
  const clockid_t(this.value);

  static clockid_t fromValue(int value) => switch (value) {
        0 => _CLOCK_REALTIME,
        6 => _CLOCK_MONOTONIC,
        4 => _CLOCK_MONOTONIC_RAW,
        5 => _CLOCK_MONOTONIC_RAW_APPROX,
        8 => _CLOCK_UPTIME_RAW,
        9 => _CLOCK_UPTIME_RAW_APPROX,
        12 => _CLOCK_PROCESS_CPUTIME_ID,
        16 => _CLOCK_THREAD_CPUTIME_ID,
        _ => throw ArgumentError("Unknown value for clockid_t: $value"),
      };
}

/// This structure contains the signal parameters.
final class EdfParam extends ffi.Struct {
  /// !< Label (name) of the signal, null-terminated string.
  @ffi.Array.multi([17])
  external ffi.Array<ffi.Char> label;

  /// !< Number of samples in the file.
  @ffi.LongLong()
  external int smp_in_file;

  /// !< Physical maximum, usually the maximum input of the ADC.
  @ffi.Double()
  external double phys_max;

  /// !< Physical minimum, usually the minimum input of the ADC.
  @ffi.Double()
  external double phys_min;

  /// !< Digital maximum, usually the maximum output of the ADC, cannot not be higher than 32767 for EDF or 8388607 for BDF.
  @ffi.Int()
  external int dig_max;

  /// !< Digital minimum, usually the minimum output of the ADC, cannot not be lower than -32768 for EDF or -8388608 for BDF.
  @ffi.Int()
  external int dig_min;

  /// !< Number of samplesin a datarecord, if the datarecord has a duration of one second (default), then it equals the sample rate.
  @ffi.Int()
  external int smp_in_datarecord;

  /// !< Physical dimension (unit, e.g. uV, bpm, mA, etc.), null-terminated string.
  @ffi.Array.multi([9])
  external ffi.Array<ffi.Char> physdimension;

  /// !< Prefilter settings, null-terminated string.
  @ffi.Array.multi([81])
  external ffi.Array<ffi.Char> prefilter;

  /// !< Transducer (sensor), null-terminated string.
  @ffi.Array.multi([81])
  external ffi.Array<ffi.Char> transducer;
}

/// This structure is used for annotations/events/triggers.
final class EdfAnnotation extends ffi.Struct {
  /// !< Onset time of the event, expressed in units of 100 nanoseconds and relative to the start of the recording.
  @ffi.LongLong()
  external int onset;

  /// !< Duration, expressed in units of 100 nanoseconds, if less than zero: unused or not applicable.
  @ffi.LongLong()
  external int duration_l;

  /// !< Duration, expressed in seconds, this is a null-terminated ASCII string.
  @ffi.Array.multi([20])
  external ffi.Array<ffi.Char> duration;

  /// !< Description of the annotation/event/trigger, this is a null-terminated UTF8 string.
  @ffi.Array.multi([513])
  external ffi.Array<ffi.Char> annotation;
}

/// This structure contains the general header info and parameters. It will be filled when calling the function edfopen_file_readonly().
final class EdfHdr extends ffi.Struct {
  /// !< A handle (identifier) used to distinguish the different files or -1 in case of an error.
  @ffi.Int()
  external int handle;

  /// !< 0: EDF, 1: EDF+, 2: BDF, 3: BDF+, a negative number indicates an error code.
  @ffi.Int()
  external int filetype;

  /// !< Number of signals in the file, annotation channels are not included.
  @ffi.Int()
  external int edfsignals;

  /// !< Duration of the file expressed in units of 100 nanoseconds.
  @ffi.LongLong()
  external int file_duration;

  /// !< Startdate: day: 1 - 31
  @ffi.Int()
  external int startdate_day;

  /// !< Startdate: month: 1 - 12
  @ffi.Int()
  external int startdate_month;

  /// !< Startdate: year: 1985 - 2084
  @ffi.Int()
  external int startdate_year;

  /// !< Starttime subsecond expressed in units of 100 nanoseconds. Is always less than 10000000 (one second). Only used by EDF+ and BDF+.
  @ffi.LongLong()
  external int starttime_subsecond;

  /// !< Starttime: second: 0 - 59
  @ffi.Int()
  external int starttime_second;

  /// !< Starttime: minute: 0 - 59
  @ffi.Int()
  external int starttime_minute;

  /// !< Starttime: hour: 0 - 23
  @ffi.Int()
  external int starttime_hour;

  /// !< Null-terminated string, contains patient field of header, is always empty when filetype is EDFPLUS or BDFPLUS.
  @ffi.Array.multi([81])
  external ffi.Array<ffi.Char> patient;

  /// !< Null-terminated string, contains recording field of header, is always empty when filetype is EDFPLUS or BDFPLUS.
  @ffi.Array.multi([81])
  external ffi.Array<ffi.Char> recording;

  /// !< Null-terminated string, is always empty when filetype is EDF or BDF.
  @ffi.Array.multi([81])
  external ffi.Array<ffi.Char> patientcode;

  /// !< Null-terminated string, is always empty when filetype is EDF or BDF.
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> sex;

  /// !< Deprecated, use \p sex.
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> gender;

  /// !< Null-terminated string, is always empty when filetype is EDF or BDF.
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> birthdate;

  /// !< Birthdate: day: 1 - 31 (zero in case of EDF or BDF).
  @ffi.Int()
  external int birthdate_day;

  /// !< Birthdate: month: 1 - 12 (zero in case of EDF or BDF).
  @ffi.Int()
  external int birthdate_month;

  /// !< Birthdate: year: 1800 - 3000 (zero in case of EDF or BDF).
  @ffi.Int()
  external int birthdate_year;

  /// !< Null-terminated string, is always empty when filetype is EDF or BDF.
  @ffi.Array.multi([81])
  external ffi.Array<ffi.Char> patient_name;

  /// !< Null-terminated string, is always empty when filetype is EDF or BDF.
  @ffi.Array.multi([81])
  external ffi.Array<ffi.Char> patient_additional;

  /// !< Null-terminated string, is always empty when filetype is EDF or BDF.
  @ffi.Array.multi([81])
  external ffi.Array<ffi.Char> admincode;

  /// !< Null-terminated string, is always empty when filetype is EDF or BDF.
  @ffi.Array.multi([81])
  external ffi.Array<ffi.Char> technician;

  /// !< Null-terminated string, is always empty when filetype is EDF or BDF.
  @ffi.Array.multi([81])
  external ffi.Array<ffi.Char> equipment;

  /// !< Null-terminated string, is always empty when filetype is EDF or BDF.
  @ffi.Array.multi([81])
  external ffi.Array<ffi.Char> recording_additional;

  /// !< Duration of a datarecord expressed in units of 100 nanoseconds.
  @ffi.LongLong()
  external int datarecord_duration;

  /// !< Number of datarecords in the file.
  @ffi.LongLong()
  external int datarecords_in_file;

  /// !< Number of annotations/events/triggers in the file.
  @ffi.LongLong()
  external int annotations_in_file;

  /// !< array of structs containing the signal parameters.
  @ffi.Array.multi([4096])
  external ffi.Array<edflib_param_t> signalparam;
}

/// This structure contains the signal parameters.
typedef edflib_param_t = EdfParam;

/// This structure contains the general header info and parameters. It will be filled when calling the function edfopen_file_readonly().
typedef edflib_hdr_t = EdfHdr;

/// This structure is used for annotations/events/triggers.
typedef edflib_annotation_t = EdfAnnotation;

const int EDFLIB_TIME_DIMENSION = 10000000;

const int EDFLIB_MAXSIGNALS = 4096;

const int EDFLIB_MAX_ANNOTATION_LEN = 512;

const int EDFSEEK_SET = 0;

const int EDFSEEK_CUR = 1;

const int EDFSEEK_END = 2;

const int EDFLIB_FILETYPE_EDF = 0;

const int EDFLIB_FILETYPE_EDFPLUS = 1;

const int EDFLIB_FILETYPE_BDF = 2;

const int EDFLIB_FILETYPE_BDFPLUS = 3;

const int EDFLIB_MALLOC_ERROR = -1;

const int EDFLIB_NO_SUCH_FILE_OR_DIRECTORY = -2;

const int EDFLIB_FILE_CONTAINS_FORMAT_ERRORS = -3;

const int EDFLIB_MAXFILES_REACHED = -4;

const int EDFLIB_FILE_READ_ERROR = -5;

const int EDFLIB_FILE_ALREADY_OPENED = -6;

const int EDFLIB_FILETYPE_ERROR = -7;

const int EDFLIB_FILE_WRITE_ERROR = -8;

const int EDFLIB_NUMBER_OF_SIGNALS_INVALID = -9;

const int EDFLIB_FILE_IS_DISCONTINUOUS = -10;

const int EDFLIB_INVALID_READ_ANNOTS_VALUE = -11;

const int EDFLIB_ARCH_ERROR = -12;

const int EDFLIB_DO_NOT_READ_ANNOTATIONS = 0;

const int EDFLIB_READ_ANNOTATIONS = 1;

const int EDFLIB_READ_ALL_ANNOTATIONS = 2;

const int EDFLIB_NO_SIGNALS = -20;

const int EDFLIB_TOO_MANY_SIGNALS = -21;

const int EDFLIB_NO_SAMPLES_IN_RECORD = -22;

const int EDFLIB_DIGMIN_IS_DIGMAX = -23;

const int EDFLIB_DIGMAX_LOWER_THAN_DIGMIN = -24;

const int EDFLIB_PHYSMIN_IS_PHYSMAX = -25;

const int EDFLIB_DATARECORD_SIZE_TOO_BIG = -26;
